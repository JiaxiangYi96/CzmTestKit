CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     ABAQUS USER SUBROUTINE FOR COHESIVE ZONE ELEMENTS
C-----------------------------------------------------------------------      
C     ELEMENT DEFINTION:
C     PROPS(NPROPS) = USER DEFINED REAL VALUED PROPERTIES
C     NPROPS = 1 --> NORMAL STIFFNESS
C     NPROPS = 2 --> TANGENTIAL STIFFNESS
C     NPROPS = 3 --> NORMAL STRENGTH
C     NPROPS = 4 --> TANGENTIAL STRENGTH
C     NPROPS = 5 --> FRACTURE TOUGHNESS MODE-1
C     NPROPS = 6 --> FRACTURE TOUGHNESS MODE-2 & MODE-3
C     NPROPS = 7 --> BK parameter - ETA
C     NPROPS = 8 --> NUMBER OF INTEGRATION POINTS
C	    NSVARS = (NUMBER OF INTEGRATION POINTS * 3) + 1
C
C     INPUT FROM THE MODEL:
C     COORDS(K1,K2) = INTITAL K1th COORDINATE OF K2nd NODE
C     U(NDOFEL) = DISPLACEMENT
C     DU = INCREMENTAL DISPLACEMENT
C
C     USER CODE TO DEFINE RHS, AMATRX, SVARS, ENERGY, and PNEWDT:
C     RHS = RESIDUAL VECTOR
C     AMATRX = TANGENT STIFFNESS MATRIX (K)
C     SVARS = SOLUTION DEPENDENT VARIABLES
C		5 SVARS PER INTEGRATION POINT
C			SVARS(1) = DAMAGE VARIABLE d	
C			SVARS(2) = DAMAGE THRESHOLD r
C			SVARS(3) = ELEM STATUS AT INTEG POINT 
C                            1=ACTIVE, 0=DELETED
C			SVARS(4) = Mode Ratio B	
C			SVARS(5) = Energy Dissipated
C	    SVARS(NSVARS) = ELEMENT STATUS 1=ACTIVE, 0=DELETED
C     ENERGY, AND PNEWDT(SUGGESTED TIME INCREMENT) ARE NOT UPDATED
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     ABAQUS UEL TEMPLATE
C-----------------------------------------------------------------------
      SUBROUTINE UEL(RHS,AMATRX,SVARS,ENERGY,NDOFEL,NRHS,NSVARS,
     1 PROPS,NPROPS,COORDS,MCRD,NNODE,U,DU,V,A,JTYPE,TIME,DTIME,
     2 KSTEP,KINC,JELEM,PARAMS,NDLOAD,JDLTYP,ADLMAG,PREDEF,NPREDF,
     3 LFLAGS,MLVARX,DDLMAG,MDLOAD,PNEWDT,JPROPS,NJPROP,PERIOD)
      INCLUDE 'ABA_PARAM.INC'
C	From aba_param.inc by default all parameter starting with letters  
C	A-H or O-Z are defined as double precision variables. 
C	and the reset (I-N) are defined as integers. Unless otherwise 
C     defined
      DOUBLE PRECISION :: RHS(MLVARX,*),AMATRX(NDOFEL,NDOFEL),
     1 PROPS(NPROPS),SVARS(NSVARS),ENERGY(8),COORDS(MCRD,NNODE),
     2 DU(MLVARX,*),V(NDOFEL),A(NDOFEL),TIME(2),PARAMS(*),
     3 U(NDOFEL),JDLTYP(MDLOAD,*),ADLMAG(MDLOAD,*),DDLMAG(MDLOAD,*),
     4 PREDEF(2,NPREDF,NNODE),LFLAGS(*),JPROPS(*)
C-----------------------------------------------------------------------
C     INFINITESIMAL DEFORMATION FORMULATION
C-----------------------------------------------------------------------
C     DECLARING INTERNAL VARIABLES
      DOUBLE PRECISION :: X(24), I(3,3), L(12,24), M(12,24), 
     1 N(3, 12), B1(3, 12), B2(3, 12), T1(3), T2(3), R(3,3),  
     2 DA(3), DETJ, W(4), CP(2), IP(2,4), DG(3,24), GIP(3), TAU(3),
     3 DTAU(3,3), SVARIP(5), ZERO, ONE, HALF, TWO
      INTEGER IT,IT1,NCOUNT,NINTP
      EXTERNAL SFUNC, GINTP, ROTVEC, TSL, CROSS
      PARAMETER (ZERO = 0.D0, ONE = 1.D0, HALF=0.5D0, TWO=2.D0)
C     INITIALIZING INTERNAL VARIABLES
      NINTP = 4
      WRITE(7,*) 'COORDS = ', COORDS
      WRITE(7,*) 'U = ', U
      X(1:24) = U(1:24)
      DO IT = 1,8
          DO IT1=1,3
              X((IT-1)*3+IT1) = (X((IT-1)*3+IT1)+COORDS(IT1,IT))
          END DO
      END DO
      I(1:3,1:3) = ZERO
      DO IT=1,3
          I(IT,IT)=ONE
      END DO
      L(1:12,1:24) = ZERO
      M(1:12,1:24) = ZERO
      DO IT=1,12
	    L(IT,IT) = -ONE
	    L(IT,IT+12) = ONE
	    M(IT,IT) = HALF
	    M(IT,IT+12) = HALF
      END DO
      DA(1:3) = ZERO
      W(1:4) = ZERO
      CP(1:2) = ZERO
      IP(1:2,1:4) = ZERO
      N(1:3,1:12) = ZERO
      B1(1:3,1:12) = ZERO
      B2(1:3,1:12) = ZERO
      R(1:3,1:3) = ZERO
      NCOUNT = 0
      RHS(1:MLVARX,1) = ZERO
      AMATRX(1:NDOFEL,1:NDOFEL) = ZERO
C	    INITIALIZING STATE DEPENDENT VARIABLES AT T=0
      IF (TIME(2).LE.ZERO) THEN
        SVARS(1:NSVARS) = ZERO
        DO IT = 1,NINTP
          SVARS(5*IT-2) = ONE
        END DO
        SVARS(NSVARS) = ONE
      END IF
C	    ROTATION VECTOR
      CALL SFUNC(CP, N, B1, B2)
      T1(1:3) = MATMUL(MATMUL(B1,M),X)
      T2(1:3) = MATMUL(MATMUL(B2,M),X)
      CALL CROSS(T1, T2, DA)
      DETJ = DSQRT(SUM(DA*DA))
C     ITERATING THROUGH INTEGRATION POINTS
      CALL GINTP(NINTP,W,IP)
      DO IT = 1,NINTP
	    CALL SFUNC(IP(:,IT), N, B1, B2)
          T1(1:3) = MATMUL(MATMUL(B1,M),X)
          T2(1:3) = MATMUL(MATMUL(B2,M),X)
          CALL CROSS(T1, T2, DA)
          DETJ = DSQRT(SUM(DA*DA))
          CALL ROTVEC(T1,T2,R)
          DG(1:3,1:24) = MATMUL(MATMUL(R,N),L)
          GIP(1:3) = MATMUL(DG,U)
          Write(7,*) 'DG = ', DG
C         TSL
          SVARIP(1:5) = SVARS(((5*(IT-1))+1) : (5*IT))
          CALL TSL(GIP, PROPS, SVARIP, TAU, DTAU)
          SVARS(((5*(IT-1))+1) : (5*IT)) = SVARIP(1:5)
C         UPDATING OUTPUT VARIABLES
          RHS(1:24,1) = RHS(1:24,1) 
     1      - (W(IT)*DETJ*MATMUL(TRANSPOSE(DG),TAU))
          AMATRX(1:24,1:24) = AMATRX(1:24,1:24)
     1      + (W(IT)*DETJ*MATMUL(TRANSPOSE(DG),MATMUL(DTAU,DG)))
	    IF (SVARS((5*IT)-2).EQ.ZERO) THEN
            NCOUNT = NCOUNT+1
          END IF
      END DO
      IF (NCOUNT.EQ.NINTP) THEN
          SVARS(NSVARS) = ZERO
      END IF
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     GAUSS POINTS & WEIGHTS
C-----------------------------------------------------------------------
      SUBROUTINE GINTP(NINTP,WEIGHT,IP)
      INTEGER, INTENT(IN) :: NINTP
      DOUBLE PRECISION :: ONE, THREE
      DOUBLE PRECISION, INTENT(OUT) :: WEIGHT(NINTP), IP(2,NINTP)
      PARAMETER (ONE = 1.D0, THREE = 3.D0)
      IF (NINTP.EQ.4) THEN
          WEIGHT(:) = ONE
	    IP(:,:) = -ONE
	    IP(1,2) = -IP(1,2)
	    IP(:,3) = -IP(:,3)
	    IP(2,4) = -IP(2,4)
      END IF
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     SHAPE FUNCTION
C-----------------------------------------------------------------------
      SUBROUTINE SFUNC(IP, N, B1, B2)
      INTEGER :: IT,IT1
      DOUBLE PRECISION NI(4), BI1(4), BI2(4), ZERO, ONE, QUART
      DOUBLE PRECISION, INTENT(IN) :: IP(2)
      DOUBLE PRECISION, INTENT(OUT) :: N(3,12), B1(3,12), B2(3,12)
      PARAMETER (ZERO = 0.D0, ONE=1.D0, QUART = 0.25D0)
      NI(1) = QUART*(ONE-IP(1))*(ONE-IP(2))
      NI(2) = QUART*(ONE+IP(1))*(ONE-IP(2))
      NI(3) = QUART*(ONE+IP(1))*(ONE+IP(2))
      NI(4) = QUART*(ONE-IP(1))*(ONE+IP(2))
      BI1(1) = -QUART*(ONE-IP(2))
      BI1(2) = QUART*(ONE-IP(2))
      BI1(3) = QUART*(ONE+IP(2))
      BI1(4) = -QUART*(ONE+IP(2))
      BI2(1) = -QUART*(ONE-IP(1))
      BI2(2) = -QUART*(ONE+IP(1))
      BI2(3) = QUART*(ONE+IP(1))
      BI2(4) = QUART*(ONE-IP(1))
      DO IT = 1,4
	     DO IT1 = 1,3
            N(IT1,((IT-1)*3+IT1)) = NI(IT)
	          B1(IT1,((IT-1)*3+IT1)) = BI1(IT)
            B2(IT1,((IT-1)*3+IT1)) = BI2(IT)
	     END DO
      END DO
      RETURN 
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     ROTATION VECTOR
C-----------------------------------------------------------------------
      SUBROUTINE ROTVEC(T1, T2, R)
      DOUBLE PRECISION N(3), E1(3), E2(3), E3(3)
      DOUBLE PRECISION, INTENT(IN) :: T1(3), T2(3)
      DOUBLE PRECISION, INTENT(OUT) :: R(3,3)
      EXTERNAL MAG, CROSS
      CALL MAG(T1, E1)
      CALL MAG(T2, E2)
      CALL CROSS(T1, T2, N)
      CALL MAG(N, E3)
      R(1,:) = E1
      R(2,:) = E2
      R(3,:) = E3
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     CROSS PRODUCT
C-----------------------------------------------------------------------
      SUBROUTINE CROSS(A, B, C)
      DOUBLE PRECISION, INTENT(IN) :: A(3), B(3)
      DOUBLE PRECISION, INTENT(OUT) :: C(3)
      C(1) = (A(2) * B(3)) - (A(3) * B(2))
      C(2) = (A(3) * B(1)) - (A(1) * B(3))
      C(3) = (A(1) * B(2)) - (A(2) * B(1))
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     UNIT VECTOR
C-----------------------------------------------------------------------
      SUBROUTINE MAG(V, VUNIT)
      DOUBLE PRECISION VMAG
      DOUBLE PRECISION, INTENT(IN) :: V(3)
      DOUBLE PRECISION, INTENT(OUT) :: VUNIT(3)
      VMAG = DSQRT(SUM(V*V))
      VUNIT = V/VMAG
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     BILINEAR TRACTION SEPERATION LAW 
C-----------------------------------------------------------------------
      SUBROUTINE TSL(DEL, PROPS, SVARS, TRACT, DTANG)
      INTEGER :: I,J,NCOUNT
      DOUBLE PRECISION :: ZERO, ONE, STIF(3), TAUN, TAUT, GNC, GTC,
     1 VAR(2), PERTM, PERTS, DELPER(3), TRCPER(3)
      DOUBLE PRECISION, INTENT(IN) :: DEL(3), PROPS(*)
      DOUBLE PRECISION, INTENT(INOUT) :: SVARS(5)
      DOUBLE PRECISION, INTENT(OUT) ::  TRACT(3), DTANG(3,3)
      PARAMETER (ZERO = 0.D0, ONE = 1.D0)
      EXTERNAL TRACVC
C     ENSURING NON ZERO DISPLACEMENT JUMP
      NCOUNT = 0
      DO I = 1,3
          IF (DEL(I).EQ.ZERO) THEN
            NCOUNT = NCOUNT+1
          END IF
      END DO
C     IF ZERO DISPLACEMENT JUMP
      IF (NCOUNT.EQ.3) THEN
C	      PROPERTIES
          STIF = ZERO
          STIF(3) = DBLE(PROPS(1)) !STIFFNESS
          TAUN = DBLE(PROPS(2)) !NORMAL STRENGTH
          TAUT = DBLE(PROPS(3)) !TANGENTIAL STRENGTH
          GNC = DBLE(PROPS(4)) !FRACTURE TOUGHNESS MODE-1
          GTC = DBLE(PROPS(5)) !FRACTURE TOUGHNESS MODE-2 & MODE-3
          STIF(1) = STIF(3) * (GNC/GTC) * ((TAUT/TAUN)*(TAUT/TAUN))
          STIF(2) = STIF(1)
          TRACT(1:3) = ZERO
          DTANG = ZERO
          DO I = 1,3
		      DTANG(I,I) = (ONE-SVARS(1))*STIF(I)
          END DO
C     ELSE PROCEEDING WITH TSL CALCULATION
      ELSE
C         TRACTION VECTOR
          TRACT = ZERO
          VAR = SVARS(1:2)
          CALL TRACVC(DEL, PROPS, VAR, TRACT)
          SVARS(1:2) = VAR
          IF (SVARS(1).EQ.ONE) THEN
              SVARS(3) = ZERO
          END IF      
C	    MATERIAL TANGENT STIFFNESS MATRIX
          DTANG = ZERO
          TRCPER = ZERO
          PERTM = 1.0D-6 !MAGNITUDE OF THE PERTURBATION
          DO I = 1,3
            VAR = SVARS(1:2)
            IF (DEL(I).NE.ZERO) THEN
                PERTS = DEL(I) / DSQRT(DEL(I)*DEL(I))
            ELSE
                PERTS = ONE
            END IF
            DELPER = DEL
            DELPER(I) = DELPER(I) + (PERTM*PERTS)
            CALL TRACVC(DELPER, PROPS, VAR, TRCPER)
            DTANG(1:3,I) = (TRCPER(1:3) - TRACT(1:3)) / (PERTM*PERTS)
          END DO
      END IF
      RETURN 
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     TRACTION VECTOR
C     VAR(1) = DAMAGE VARIABLE
C     VAR(2) = THRESHOLD FUNCTION
C-----------------------------------------------------------------------
      SUBROUTINE TRACVC(DELIN, PROPS, VAR, TRACT)
      DOUBLE PRECISION :: TEMP, ZERO, ONE, TWO, DELMC,
     1 TAUN, TAUT, GNC, GTC, ETA, DELN, DELT, DELNO2, DELTO2,
     2 JMPTEN, B, DEL(3), DELOM, DELFM, H, STIFN, STIFT, STIFB,
     3 G1, G2, G1O, G2O
      DOUBLE PRECISION, INTENT(IN) :: DELIN(3), PROPS(*) 
      DOUBLE PRECISION, INTENT(INOUT) :: VAR(2)
      DOUBLE PRECISION, INTENT(OUT) :: TRACT(3)
      PARAMETER (ZERO = 0.D0, ONE = 1.D0, TWO = 2.D0)
      EXTERNAL MACOP
C     EXCLUDING CONTACT
      DELT = DSQRT( (DELIN(1)*DELIN(1)) + (DELIN(2)*DELIN(2)) )
      DELN = ZERO
      TEMP = DELIN(3)
      CALL MACOP(TEMP, DELN)
C	    PROPERTIES
      TAUN = DBLE(PROPS(2)) !NORMAL STRENGTH
      TAUT = DBLE(PROPS(3)) !TANGENTIAL STRENGTH
      GNC = DBLE(PROPS(4)) !FRACTURE TOUGHNESS MODE-1
      GTC = DBLE(PROPS(5)) !FRACTURE TOUGHNESS MODE-2 & MODE-3
      ETA = DBLE(PROPS(6)) !B-K PARAMETER
      STIFN = DBLE(PROPS(1)) !NORMAL STIFFNESS
      STIFT = STIFN * (GNC/GTC) * ((TAUT/TAUN)*(TAUT/TAUN))
C     MODE RATIOS
      G2 = STIFT * DELT * DELT 
      G1 = STIFN * DELN * DELN 
      B = G2 / (G1 + G2)
C	    MIXED MODE PROPERTIES
      JMPTEN = (G1 + G2) / DSQRT((STIFT * DELT)**2 + (STIFN * DELN)**2)
      STIFB = ((1-B)*STIFN) + (B*STIFT) !STIFFNESS
      G1O = TAUN * TAUN / STIFN
      G2O = TAUT * TAUT / STIFT
      DELOM = DSQRT((G1O + ((B**ETA) * (G2O - G1O))) / STIFB)
      DELFM = TWO*(GNC+((B**ETA) * (GTC - GNC)))/(STIFB*DELOM)
C     VARIABLES
      H = (JMPTEN - DELOM) / (DELFM - DELOM)
      TEMP = VAR(2)
      H = MAX(H, TEMP)
      IF (H.GT.ONE) H = ONE
      VAR(2) = H
      VAR(1) = H*DELFM / ( H*DELFM + (1-H)*DELOM )
C	    TRACTION VECTOR
      TRACT(1) = (ONE-VAR(1))*STIFT*DELIN(1)
      TRACT(2) = (ONE-VAR(1))*STIFT*DELIN(2)
      TRACT(3) = (ONE-VAR(1))*STIFN*DELIN(3)
      RETURN 
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     MACAULEY OPERATOR
C-----------------------------------------------------------------------
      SUBROUTINE MACOP(DEL, DELMC)
      DOUBLE PRECISION :: TEMP1, TEMP2, HALF
      DOUBLE PRECISION, INTENT(IN) :: DEL
      DOUBLE PRECISION, INTENT(INOUT) :: DELMC
      PARAMETER (HALF = 0.5D0)
      TEMP1 = DEL*DEL
      TEMP2 = DSQRT(TEMP1)
      DELMC = HALF*(DEL+TEMP2)     
      RETURN 
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

